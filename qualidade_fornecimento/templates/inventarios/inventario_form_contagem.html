{% extends 'base.html' %}
{% load static %}
{% block content %}

<div class="d-flex justify-content-between align-items-center mb-2">
  <h4>{{ ordem_label }} — {{ inventario.titulo }}</h4>
  <a class="btn btn-outline-secondary" href="{% url 'inventario_detail' inventario.pk %}">Voltar</a>
</div>

<p class="text-muted mb-3">
  Tipo: <strong>{{ inventario.get_tipo_display }}</strong> ·
  Status: <strong>{{ inventario.get_status_display }}</strong> ·
  Data de corte: {{ inventario.data_corte|date:"d/m/Y" }}
</p>

<div class="row g-3">
  <div class="col-12 col-lg-7">
    <div class="card shadow-sm">
      <div class="card-body">
        <h6 class="mb-2">Leitura por Câmera (QR Code)</h6>

        <!-- Pré-visualização + overlay + feedback -->
        <div class="ratio ratio-4x3 border rounded position-relative">
          <video id="preview" autoplay playsinline muted style="width:100%; height:100%; object-fit:cover;"></video>
          <canvas id="overlay" class="position-absolute" style="inset:0; pointer-events:none;"></canvas>

          <!-- badge sucesso/erro -->
          <div id="scan-feedback"
               role="status"
               aria-live="polite"
               class="position-absolute translate-middle-x d-none"
               style="left:50%; top:10%; background:#16a34a; color:#fff; padding:.45rem .75rem; border-radius:999px; box-shadow:0 .5rem 1rem rgba(0,0,0,.15); font-weight:600;">
            <span id="scan-feedback-icon" style="margin-right:.35rem;">✓</span>
            <span id="scan-feedback-text">Leitura registrada</span>
          </div>
        </div>

        <!-- ordem visível ao JS da câmera -->
        <input type="hidden" id="ordem-camera" value="{{ ordem }}"/>

        <div class="d-flex flex-wrap gap-2 mt-2 align-items-center">
          <button id="btn-start" class="btn btn-primary">Iniciar câmera</button>
          <button id="btn-stop" class="btn btn-outline-secondary" disabled>Parar</button>
          <button id="btn-torch-on"  class="btn btn-dark" type="button">Lanterna ON</button>
          <button id="btn-torch-off" class="btn btn-outline-dark" type="button">Lanterna OFF</button>
          <div class="d-flex align-items-center gap-2">
            <label class="form-label m-0">Zoom</label>
            <input id="zoom-range" type="range" min="1" max="3" step="0.1" value="1" style="width:160px;">
          </div>
        </div>

        <div class="form-text mt-2">
          A cada QR lido, o item é registrado automaticamente (ordem {{ ordem }}).
          Se o QR trouxer o <em>peso</em> no 3º campo, ele será usado como quantidade.
          Para melhor desempenho, acione a <strong>lanterna</strong>.
        </div>
      </div>
    </div>
  </div>

  <div class="col-12 col-lg-5">
    <div class="card shadow-sm">
      <div class="card-body">
        <h6 class="mb-2">Entrada Manual (opcional)</h6>
        <form id="form-manual" class="row g-2" autocomplete="off">
          {% csrf_token %}
          <div class="col-12">
            <label class="form-label">QR/Texto da Etiqueta</label>
            {{ form.origem_qrcode }}
          </div>
          <div class="col-12 col-md-6">
            <label class="form-label">Quantidade</label>
            {{ form.quantidade }}
          </div>
          <input type="hidden" id="ordem" name="ordem" value="{{ ordem }}"/>
          <div class="col-12">
            <button type="button" id="btn-manual" class="btn btn-outline-primary">Registrar manualmente</button>
          </div>
        </form>
      </div>
    </div>
  </div>
</div>

<!-- Últimos lidos -->
<div class="card mt-3 shadow-sm">
  <div class="card-body">
    <h6 class="mb-2">Últimos lidos</h6>
    <div id="lista-lidos" class="small text-muted">Nenhuma leitura ainda.</div>
  </div>
</div>

<!-- Finalizar contagem -->
<form class="mt-3" method="post" action="{% url 'finalizar_contagem' inventario.pk ordem %}">
  {% csrf_token %}
  <button type="submit" class="btn btn-success btn-lg">Finalizar {{ ordem_label }}</button>
</form>

<style>
  #scan-feedback.show { animation: fadeInOut 2s ease-in-out both; }
  @keyframes fadeInOut {
    0%   { opacity: 0; transform: translate(-50%, -6px); }
    10%  { opacity: 1; transform: translate(-50%, 0); }
    80%  { opacity: 1; transform: translate(-50%, 0); }
    100% { opacity: 0; transform: translate(-50%, -6px); }
  }
</style>

<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>

<script>
// ================= Utilidades =================
function getCookie(name) {
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) return decodeURIComponent(parts.pop().split(';').shift());
  return '';
}
function beep() {
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator(), g = ctx.createGain();
    o.connect(g); g.connect(ctx.destination);
    o.type = 'sine'; o.frequency.value = 1000; g.gain.value = 0.06;
    o.start(); setTimeout(()=>{o.stop(); ctx.close();}, 120);
  } catch(e){}
}
function vibrate(ms=60){ if (navigator.vibrate) navigator.vibrate(ms); }

async function enviarLeitura(qrcode, quantidade, ordem) {
  const resp = await fetch("{% url 'api_scan_qrcode' inventario.pk %}", {
    method: "POST",
    headers: {
      "X-CSRFToken": getCookie("csrftoken"),
      "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"
    },
    body: new URLSearchParams({ qrcode, quantidade: quantidade || "", ordem })
  });
  return resp.json();
}
function appendLido(qr, qtd) {
  const el = document.getElementById('lista-lidos');
  const now = new Date().toLocaleTimeString();
  const line = document.createElement('div');
  line.textContent = `[${now}] ${qr} — qtd: ${qtd || 'auto'}`;
  if (el && el.textContent === 'Nenhuma leitura ainda.') el.textContent = '';
  if (el) el.prepend(line);
}

// ===== Feedback (sucesso/erro) 2s =====
function showFeedback(kind='success', msg='Leitura registrada') {
  const fb = document.getElementById('scan-feedback');
  const icon = document.getElementById('scan-feedback-icon');
  const text = document.getElementById('scan-feedback-text');
  if (!fb) return;
  // estilo
  if (kind === 'success') {
    fb.style.background = '#16a34a'; icon.textContent = '✓';
  } else {
    fb.style.background = '#dc2626'; icon.textContent = '!';
  }
  text.textContent = msg;

  fb.classList.remove('d-none','show'); fb.offsetWidth; fb.classList.add('show');
  clearTimeout(showFeedback._t);
  showFeedback._t = setTimeout(() => { fb.classList.add('d-none'); fb.classList.remove('show'); }, 2000);
}

// ============== Scanner com jsQR + FILA ==============
const video   = document.getElementById('preview');
const overlay = document.getElementById('overlay');
const octx    = overlay.getContext('2d');

const btnStart = document.getElementById('btn-start');
const btnStop  = document.getElementById('btn-stop');
const btnTorchOn  = document.getElementById('btn-torch-on');
const btnTorchOff = document.getElementById('btn-torch-off');
const zoomRange   = document.getElementById('zoom-range');

let stream = null, track = null, rafId = null;
let buffer = null, bctx = null;

// Fila de leituras para garantir ordem e não perder requests
const queue = [];
let processing = false;

// Evita reprocessar a mesma etiqueta por 2s
const recent = new Map(); // valor -> timestamp
const DEDUP_MS = 2000;

function enqueueRead(raw) {
  // dedup por 2s
  const now = Date.now();
  const last = recent.get(raw) || 0;
  if (now - last < DEDUP_MS) return;
  recent.set(raw, now);

  queue.push(raw);
  processQueue().catch(()=>{});
}

async function processQueue() {
  if (processing) return;
  processing = true;
  const ordem = document.getElementById('ordem-camera')?.value || "{{ ordem }}";
  while (queue.length) {
    const raw = queue.shift();
    try {
      const data = await enviarLeitura(raw, '', ordem);
      // console.debug('SCAN RESP', raw, data);
      if (data && data.ok) {
        appendLido(raw, 'auto');
        beep(); vibrate();
        showFeedback('success', 'Leitura registrada');
        // Opcional: recarregar a página a cada X registros
        // if ((processQueue._count = (processQueue._count||0)+1) % 10 === 0) location.reload();
      } else {
        const erro = (data && (data.erro || data.detail)) || 'Falha ao registrar';
        showFeedback('error', erro);
      }
    } catch (e) {
      showFeedback('error', 'Erro de comunicação');
    }
  }
  processing = false;
}

function ensureBuffer() {
  if (!buffer) {
    buffer = document.createElement('canvas');
    buffer.style.display = 'none';
    document.body.appendChild(buffer);
    bctx = buffer.getContext('2d', { willReadFrequently: true });
  }
}
function resizeSurfaces() {
  if (!video.videoWidth || !video.videoHeight) return;
  const bw = Math.max(1280, video.videoWidth);
  const bh = Math.round(bw * (video.videoHeight / video.videoWidth));
  buffer.width = bw; buffer.height = bh;
  const rect = video.getBoundingClientRect();
  overlay.width = rect.width;
  overlay.height = rect.height;
}
function drawOverlayBox(loc) {
  if (!loc) { octx.clearRect(0,0,overlay.width,overlay.height); return; }
  octx.clearRect(0,0,overlay.width,overlay.height);
  const pts = [loc.topLeftCorner, loc.topRightCorner, loc.bottomRightCorner, loc.bottomLeftCorner];
  const sx = overlay.width / buffer.width;
  const sy = overlay.height / buffer.height;
  octx.lineWidth = 3;
  octx.strokeStyle = '#00ff88';
  octx.beginPath();
  octx.moveTo(pts[0].x*sx, pts[0].y*sy);
  for (let i=1;i<pts.length;i++) octx.lineTo(pts[i].x*sx, pts[i].y*sy);
  octx.closePath();
  octx.stroke();
}

async function startCamera() {
  if (stream) return;
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: { ideal: 'environment' },
        width:  { ideal: 1920 },
        height: { ideal: 1080 },
        advanced: [{ focusMode: "continuous" }]
      },
      audio: false
    });
  } catch (e) {
    alert('Não foi possível acessar a câmera. Se não for localhost, use HTTPS.');
    return;
  }
  track = stream.getVideoTracks()[0];
  video.srcObject = stream;
  await video.play().catch(()=>{});
  ensureBuffer();
  resizeSurfaces();
  btnStart.disabled = true; btnStop.disabled = false;
  scanLoop();
}
function stopCamera() {
  if (rafId) cancelAnimationFrame(rafId); rafId = null;
  if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; track = null; }
  octx.clearRect(0,0,overlay.width,overlay.height);
  btnStart.disabled = false; btnStop.disabled = true;
}
async function scanLoop() {
  if (!stream || !video.videoWidth) { rafId = requestAnimationFrame(scanLoop); return; }
  resizeSurfaces();
  bctx.drawImage(video, 0, 0, buffer.width, buffer.height);
  const img = bctx.getImageData(0, 0, buffer.width, buffer.height);
  const res = jsQR(img.data, img.width, img.height, { inversionAttempts: 'attemptBoth' });

  if (res && res.data) {
    drawOverlayBox(res.location);
    const raw = res.data.trim();
    if (raw) enqueueRead(raw);
  } else {
    octx.clearRect(0,0,overlay.width,overlay.height);
  }
  rafId = requestAnimationFrame(scanLoop);
}

// --------- Torch (lanterna) e Zoom ---------
async function setTorch(on) {
  if (!track || !track.getCapabilities) return false;
  const caps = track.getCapabilities();
  if (!caps.torch) return false;
  try { await track.applyConstraints({ advanced: [{ torch: !!on }] }); return true; }
  catch { return false; }
}
async function setZoom(level) {
  if (!track || !track.getCapabilities) return;
  const caps = track.getCapabilities();
  if (!caps.zoom) return;
  const z = Math.min(caps.zoom.max || 3, Math.max(caps.zoom.min || 1, Number(level)));
  try { await track.applyConstraints({ advanced: [{ zoom: z }] }); } catch{}
}

// --------- Eventos ---------
btnStart?.addEventListener('click', (e)=>{ e.preventDefault(); startCamera(); });
btnStop ?.addEventListener('click', (e)=>{ e.preventDefault(); stopCamera(); });
btnTorchOn ?.addEventListener('click', async (e)=>{ e.preventDefault(); const ok = await setTorch(true); if(!ok) alert('Lanterna não suportada neste dispositivo.'); });
btnTorchOff?.addEventListener('click', async (e)=>{ e.preventDefault(); await setTorch(false); });
zoomRange   ?.addEventListener('input', (e)=>{ setZoom(e.target.value); });

// --------- Leitura manual (com feedback de erro/sucesso) ---------
document.getElementById('btn-manual')?.addEventListener('click', async ()=>{
  const qr   = document.getElementById('id_origem_qrcode')?.value.trim();
  const qtd  = document.getElementById('id_quantidade')?.value.trim();
  const ordem= document.getElementById('ordem')?.value;
  if (!qr) { alert('Informe o QR/Texto.'); return; }
  try {
    const data = await enviarLeitura(qr, qtd, ordem);
    if (data && data.ok) {
      appendLido(qr, qtd);
      document.getElementById('id_origem_qrcode').value = '';
      document.getElementById('id_quantidade').value = '';
      document.getElementById('id_origem_qrcode').focus();
      beep(); vibrate(); showFeedback('success', 'Leitura registrada');
    } else {
      const erro = (data && (data.erro || data.detail)) || 'Falha ao registrar';
      showFeedback('error', erro);
    }
  } catch {
    showFeedback('error', 'Erro de comunicação');
  }
});

// Reajusta superfícies quando o vídeo estiver pronto
video.addEventListener('loadedmetadata', resizeSurfaces);
window.addEventListener('resize', resizeSurfaces);
</script>

{% endblock %}
